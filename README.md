ctrl + shift + t открыть только что закрытую вкладку в браузере
ctrl + z; ctr; + shift + z - туда сюда
ctrl + space - додумывалка

TodoList lesson 1

Создаем компоненту Todolist и выносим в отдельный файл
Для выноса в отдельный файл используем F6

Если мы в jsx разметке указываем в атрибуте текст то достаточно обернуть его в кавычки 
но вообще после знака = нужно ставить {}

Если экспортируем компоненту по дефолту то в импорте можем менять название но тогда и этой компоненте нужно указывать
наименование как в импорте что в целом вводит путаницу так что является бесполезной возможностью

Экспортируем без дефолта

Когда нам нужно затипизировать массив с объектами 
нужно сначала создать типизацию для конкретного объекта в массиве и уже потом указывать это наименовение после

type TasksDataType = {
    id: number
    title: string
    isDone: boolean
}

type PropsType = {
    tasksData : Array<TasksDataType> or TasksDataType[]
}

Искать проблему нужно в том числе на одно действие выше от ошибки

Чтобы не ошибиться во время описания объектов можем использовать уже написанную типизацию 
в том числе и из других компонент

Todolist.tsx

export type TasksDataType = {
    id: number
    title: string
    isDone: boolean
}

App.tsx

let tasks_2: Array<TasksDataType> = [
    {id: 1, title: 'satisfaction', isDone: true },
    {id: 2, title: 'satisfaction', isDone: true },
    {id: 3, title: 'satisfaction', isDone: false },
]

TodoList Lesson 2

Данные помещены в App компонент и эти данные передаем в Todolist компонент
Данные в App потому что мы не собираемся рисовать 2 компоненты
В Todolist данные мы будем хранить в UI в компоненте App потому что у React 
есть механизмы хранения и управления данными, но в реальной жизни этот локальный стейт
managment используется для локальных не больших заданий

Для большого управления state используется redux
Пока данные хранятся в виде переменных в App компоненте и мы эти данные прокидываем
в разные Todolist, мы не храним эти данные в Todolist потому что его мы отрисовываем несколько раз
а App один раз а значит Todolist при каждой отрисовке они должен быть разным поэтому так

Теперь если мы добавим 4 объект в массив объектов tasks то увидим что 4 объект не отобразился
id должен быть уникальным (уникальный идентификатор объекта)

Наша разметка зависит от данных которые мы в эту разметку помещаем мы как программисты
думаем как нам правильно составлять данные и как их потом менять а разметка автоматически сама подстроится

Мы добавили 4 элемент а разметка сама не подстроилась
этого не произошло потому что компонент TodoList не правильно структурирован
не правильно построен

Основная ошибка в том что мы явно обращаемся к элементам в массиве по индексу
мы как-будто знаем что у нас должно быть строго 3 таски 
Поэтому 4 таска и не отрисовывается потому что ее просто нет
Поэтому если мы удалим в таскс 2 3 объект приложение будет просто показывать белый экран

Если мы обратимся по индексу массива а в массиве ничего не будет нам вернется undefined

Поэтому код нашей компоненты - не гибкий он не заточен под любое количество тасок
которое может прийти а может и не прийтий

Поэтому мы должны использовать здесь метод массива map
массив это объект
в Todolist в ul Ставим {обозначаем что мы сейчас будем работать с js}
массив находится в props
props.tasks это какой-то массив тасок который приходит в нашу компоненту

Todolist может отрисовываться много раз и tasks могут быть разными и они находятся
в props
props это объект который приходит в нашу компоненту чтобы наша компонента на основе этих данных
могла отрисовать какую-то другую разметку например заголовок props.title 
или например список тасок
поэтому мы должны пробежаться по каждому элементу по каждому объекту в массиве
и делаем это с помощью функции map

{
    props.tasks.map
}

в отличие от forEach map после каждой итерации возвращает на основе старого объекта - новый объект
в новом массиве, нам нужно чтобы он вернул на основе этого объекта - элемент списка - li

1 в map передаю стрелочную функцию

{
    props.tasks.map(  () => {} )
}

Единственным параметром который передается в map является callback функция
с помощью map callback функция вызывается для каждого элемента в tasksData_1_2
этот параметр можно назвать как угодно но лучше чтобы он был в контексте программы

<ul>
    {
        props.tasksData.map((tasksDataItem) => {
            return (
                <li><input type="checkbox" defaultChecked={props.tasksData[0].isDone}/> <span>{props.tasksData[0].title}</span></li>
            )
        })
    }

то есть map возьмет на основе всех объектов tasksData создаст столько же li сколько в tasks находится объектов
но чтобы значения в этой li согласовывались с данными из объектов tasksData мы должны считывать эти значения уже не по индексу
а прямо из параметра callback функции task поэтому в li будут следующие изменения

<ul>
    {
        props.tasksData.map(tasks => {
            <li><input type="checkbox" defaultChecked={task.isDone}/> 
            <span>{task.title}</span></li>
        }
</ul>

И теперь независимо от того сколько объектов мы добавим в массив tasks у нас соответствующее количество
отрисуется и соотв если я укажу в tasksData 2 то у меня 2 объекта и отрисуется.

Рефакторинг так как ничего кроме return функция в map не делает то мы можем сократить запись

map - метод массива который на основе каждого объекта в массиве создает другой элемент
на выходе мы получаем массив с этими новыми элементами

То есть теперь мы просто меняя данные можем автоматически менять разметку

и если мы научимся как-то менять эти данные программным способом, при кликах
по кнопкам и т.д. то у нас будет автоматически происходить перерисовка
и первое что мы научимся делать - удалять таски

Добавляем кнопки справа от span в li

<button>x</button>

Учимся реагировать на события, когда по какому-либо элементу, по кнопке например, 
когда мы кликаем этот элемент генерирует событие клик, 
но так как никто это собтие не слушает, не мониторит,
то ничего и не происходит,
поэтому создаем такого слушателя и добавим тегу button - атрибут onClick
Далее так указываем функцию callback 
Когда произойдет клик функция callback как раз сообщит об этом событии внешнему миру
через функцию которую вызовет кнопка когда с ней произойдет событие клик

И мы отдаем кнопке стрелочную функцию 

<button onClick={() => {}}>x</button>
 
Добавим окошко которое будет вылетать по клику с надписью click

 <ul>
    {
        props.tasksDataApp.map((tasksDataAppItem) =>
            <li>
                <input type="checkbox" defaultChecked={tasksDataAppItem.isDone}/>
                <span>{tasksDataAppItem.title}</span>
                <button className={'deleteButton'} onClick={() => {alert('click')}}>x</button>
            </li>
        )
    }
</ul>

и теперь после нажатия на любую кнопку x будет выводиться окно с надписью click

так как на другие кнопки мы не вешали события onClick то ничего после нажатия по ним не происходит

Функция кнопки x - удалять из отображения браузера конкретную таску, а чтобы реакту было понятно
какую именно таску нужно удалять мы должны каким-то образом идентифицировать конкретный элемент который 
должен быть удален после нажатия на кнопку

Эта идентификация объектов с которыми нужно что-то сделать происходит по id

То есть нам нужно знать id объекта когда мы хотим его например удалить
Вместо click выведем id объекта
мы находимся внутри стрелочной функции которую мы передали в метод map 
map вызывает эту стрелочную функцию для каждой таски в этом массиве поочереди
и при каждом вызове эта таска попадает в параметр task
для которой мы рисуем конкретную li для которой рисуем конкретную кнопку
для которой хотим показать алерт то есть мы к конкретной таске можем достучаться через

task

и я могу к этому task обратиться как к объекту со свойствами каждой таски
например к свойству id

<button onClick={() => { alert(task.id) }}>x</button>

то есть при клике на конкретную кнопку теперь у меня будет отображаться id той таски рядом
с которой я кликнул кнопку то есть мы получили ту самую связь

то есть при клике на кнопку которая лежит в li, которая отрисовалась для конкретной task,
мы повесили конкретную функцию обработчик onClick={() => { alert(task.id) }
на клик конкретной кнопки конкретной li и эта конкретная функция покажет в alert id той таски 
рядом с которой я кликнул кнопку

Для упрощения пока удалим 1 Todolist

Наша задача удалить таску удалить ее мы можем только из данных, в компоненте Todolist мы ее удалить не можем,
массив с тасками находится в App компоненте

То есть данные хранятся в App, а мы эти данные просто как пропсы прокидываем в Todolist и 
Todolist их просто рисует, но мы знаем что мы данные будем менять

то есть мы при нажатии на какие-либо кнопки всегда думаем как нам поменять данные, а уже потом
на основе этих данных произойдет перерисвока

То есть мы должны таким образом писать код для компоненты чтобы потом если вдруг данные меняются
автоматически происходила перерисовка 

Мы подготовили компоненту теперь нужно научиться менять данные

Данные могут менять только функции которые лежат там же где и данные 

Но функцию чтобы она поменяла данные нужно запустить, вызвать, но App сама не может запустить такую функцию
потому что она не знает когда, но Todolist знает, когда нужно запустить эту функцию удаления

Потому что кнопки удаления лежат в Todolist и фактически когда мы кликаем по Tosolist нужно запустить
эту функцию которая лежит в App

Когда у нас данные лежали в App мы передали их в Todolist через props и функция у нас лежит там в App
и мы ее передадим в Todolist так же через props, то есть функция является в js объектом значит ее можно брать
и передавать (передать callback когда сам владелец функции ее не вызывает) App ее не вызывает
а передает куда-то внутрь мы так уже делали с функцией alert('click')

То есть мы ее сами не вызываем мы ее передаем кнопке

<button onClick={() => { alert(task.id) }}>x</button>

И говорим: кнопка, когда по тебе кликнут (onClick) вызови нашу функцию callback

В какой-то степени сама компонента является функцией callback потому что мы ее не вызываем 
мы не видим кода, где у нас конкретно пишется Todolist(); - то есть вызов функции Todolist,
Мы даем инструкцию react в виде jsx разметки и потом эту функцию вызывает React 

Есть еще одна функция callback, это map, мы в map в качестве параметра тоже передаем стрелочную функцию
которая принимает task и возвращает li, мы эту функцию не вызываем, мы ее отдаем map, то есть другой функции
и эта функция map запускает для каждой таски функцию callback

Под задачу удалить таску из массива напишем функцию удаления таски из массива в App

function removeTask() {

}

Но мы не можем удалить task не зная какую именно task удалить
то есть нам как функции удаления нужны входные данные

Функция removeTask лежит там же где и массив с объектами

Удалять объекты из массива будем по id и тут же будет необходимо определить тип под id: number

function removeTask(id: number) {

}

Теперь нам нужно взять этот массив тасок и его изменить, оставив все таски кроме одной
той которую мы удалили для этого используем метод массива filter

map на основе старого массива создает новый массив изменяя каким-либо образом все элементы массива

а filter так же пробегает по всем объектам и пропускает в результирующий массив только те объекты
которые удовлетворяют условию то есть только те таски для которых функция callback переданная в filter
вернёт true 
То есть в новом массиве после filter будут только те таски после прохождения по фильтру которых
filter вернет true

Если написать 

function removeTask(id: number) {
    let filteredTasksData = tasksData.filter(() => {return true})
    console.log(filteredTasksData)
}

то filter вернет те же самые объекты но в новом массиве
Для того чтобы это проверить вызовем эту функцию после клика по кнопке
кнопка находится в Todolist а функция находится в App
значит функцию нужно передать в Todolist через props

<Todolist
    title={'push me'}
    tasksDataApp={tasksData}
    removeTask={removeTask}
/>

в типизации мы укажем 

type TodolistType = {
    title: string
    tasksDataApp: Array<TaskDataType>
    removeTask: Function
}

и теперь мы можем вместо alert вызвать функцию которая у нас находится в props 

То есть мы можем написать вместо alert props.removeTask.id 
таким образом передать в функцию id той кнопки на которую мы нажали для удаления таски

<button onClick={() => { alert(task.id) }}>x</button>            Было
<button onClick={() => { props.removeTask(task.id) }}>x</button> Стало

Итого кнопку нажали в Todolist а функция работает из App компоненты
то есть вызов функции removeTask() произошел в Todolist не смотря на то что сама функция находится в App

Теперь мы должны настроить правильную фильтрацию

То есть мы должны пропустить только те таски у которых id не равна той id которую надо удалить
(на х рядом с которой мы нажали)

как и с map каждая таска приходит с параметром callback функции назовем его 

filteredTask

Далее в filter пишем условие по которому нам фильтр будет фильтровать проходящие через него
объекты массива и после каждого выдавать соотв true либо false

То есть мы говорим если filteredTask.id (таска по которой пробегается фильтр) если ее id не равен
id которая пришла в функцию после клика по кнопке в Todolist то мы тогда возвращаем true
и таску отображаем
а если id таски фильтра равна id таски с кнопки х todolista то возвращаем false и таску не отображаем

function removeTask(id: number) {
    let filteredTasksData = tasksData.filter((filteredTask) => {
        if (filteredTask.id !== id) return true
        else return false
        })
}

То есть мы выше сравниваем id кнопки по которой мы нажали с id таски из данных, и если они совпадают
не показываем эту таску с помощью того что фильтр возращает новый массив уже без нее
т.о. мы меняем данные

Если мы нажмем на x с id 3 то для таски с id 3 filter вернет false значит эта таска не попадет в 
результирующий массив 

if (1 !== 3) true - отобрази
if (2 !== 3) true - отобрази
if (3 !== 3) false - не отображай
if (4 !== 3) true - отобрази

Соответственно в результирующем массиве у нас будут таски с id 1 2 4 а 3 - нет

_________________________Рефакторим filter 

так как булевое выражение итак нам возращает true либо false
то
мы можем упростить наш код

function removeTask(id: number) {
    let filteredTasksData = tasksData.filter((filteredTask) => {
    return filteredTask.id !== id
}
filteredTask.id !== id превращается либо в true либо в false
а filter добавит в новый массив только там где true
поэтому id присовпадении не попадут в результирующий массив

Если наша стрелочная функция не делает ничего кроме return то мы можем удалить {} и return

итого

function removeTask(id: number) {
    let filteredTasksData = tasksData.filter(filteredTask => filteredTask.id !== id)
}

Фильтр пропусти те таски id которых не равна id которую надо удалить

Но это все будет отображать уже в другом массиве, старый массив мы не меняли
фильтрация не меняет старый массив она пробегается по старому массиву и создает новый массив
с отфильтрованными тасками поэтому этот массив не изменился поэтому на данном этапе перерисовки 
после нажатия на х - нет

Но мы можем не создавать новую переменную filteredTasksData а так как у нас массив данных объявлен с помощью
let то мы можем просто переприсвоить тому же самому массиву данных tasksData новое значение
поэтому

из 

function removeTask(id: number) {
    let filteredTasksData = tasksData.filter(filteredTask => filteredTask.id !== id)
}

мы делаем 

function removeTask(id: number) {
    let tasksData = tasksData.filter(filteredTask => filteredTask.id !== id)
}

Если функция видит внутри себя наименование переменной которой нет внутри этой функции
то она ее берет из замыкания снаружи, за пределами литерала {} функции 
Это называется замыкание

Итак на данный момент после нажатия x через debugger видим как такси удаляются 
а в браузере перерисовка не происходит

Потому что реакт отрисовывает App, Todolist и так далее по цепочке, останавливается, и только потом
мы нажимаем кнопку, данные изменяются, но React заново не отрисовывает страницу 
поэтому на странице ничего не меняется

Потому что данные нам нужно хранить определенным, специальным образом 
чтобы эта перерисовка происходила автоматически

в пути самурая rerenderentiretree мы насильно извне перерисовываем компоненту 

Здесь мы будем использовать локальный стейт компонента

Раньше существовало два типа компонент функциональные и классовые

классовый компонент - то что уходит в прошлое, но раньше они широко использовались
потому что классовые компоненты имеют локальный стейт
Локальный стейт, это такой стейт, который если меняется - перерисовывает реакт компоненту

в функциональных компонентах такого не было, но в функциональных компонентах
научились использовать локальный стейт с помощью хука useState

useState

Скажем что мы будем хранить таски по другому не в переменной tasksData а в useState

useState() это специальная функция-хук которая находится в реакте 
при использовании она импортируется из реакт

мы говорим useState - сохрани данные в стейт, который будет отслеживаться реактом и если данные изменятся
то реакт автоматически перерисует компоненту в который мы написали useState

useState - хранилище, он конкретно прописан в App, значит у App - появляется свое хранилище
за которым React наблюдает и мы в этот useState помещаем нам массив tasksData

useState(tasksData)

Нам этим массивом нужно как-то пользоваться
То что мы помещаем tasksData в useState это первоначальное состояние, initial state - которому со старта будет 
равняться наш стейт при первом его написании.

Но он со временем может поменяться, и нам нужно к измененному tasksData обращаться 

Поэтому useState returnит массив в котором находится два элемента

[data, () => {}] 1 элемент это данные, а второй - функция которая эти данные меняет

в нашем случае вместо data данных выступает массив объектов [{},{},{}] и функция которая может этот массив поменять
() => {}

и вот useHook нам возвращает такой массив let array = [ [{},{},{}], () => {}] 

то есть мы вызываем функцию

useState()

которая принимает данные

useState(data) 

и которая возвращает массив

useState(data) {
    return [ [{},{},{}], () => {}];
}

то есть мы вызываем useState() и говорим вот тебе массив tasks

useState([{},{},{}])

useState берет массив тасок и возвращает обратно

function useState(data: any) {
    return [ data, () => {}];
}

то есть в useState(data: any) упаковывает data в массив тасок, а вторым парамтером функцию 
которая этот массив тасок умеет менять

и нам этот массив возвращается обратно

let array = useState({},{},{})

и мы можем обратиться к array[0] и это будет массив тасок который мы и передали
и можем обратиться к array[1] чтобы получить функцию которая меняет данные
и обычно эти два значения присваются и говорят 

let useStateTasksData = array[0]

а функция которая сидит вторым элементом в этом массиве называется 

setTasks = array[1] установить таски

То есть useState нам возвращает массив

let array = useState(tasksData)

и в этом array сидит 2 элемента

под первым элементом сидят таски
под вторым элементом сидит функция которую мы можем вызвать чтобы установить новые таски

let tasksDataUseState = array[0]
let setTasks = array[1]

то есть когда мы изменим массив tasksData мы можем этот массив отправить в 
функцию setTasks и таски изменятся там в стейте который контролируется реактом
и реакт автоматически запустит перерисовку

фильтр фильтрует по тасксдата мы получили фильтрованные таски
и теперь если мы эти отфильтрованные таски отправим в функцию setTasks
тем самым мы скажем что измени в стейте таски которые там были 
setTasks(filteredTasks)

function removeTask(id: number) {
    let filteredTasks = useStateTasksData.filter(filteredTask => filteredTask.id !== id)
    setTasks(filteredTasks)
}

А раз таски изменились с помощью setTasks реакт запустит перерисовку
точнее чтобы перерисовку вообще получить реакту нужно запустить заново функцию в которой 
этот стейт изменился

Реакт заново перезапускает функцию App он видит что мы используем функцию 

let arrayUseState = useState(tasksData)

и в этот useState засовываем опять 4 таски из tasksData

То есть у нас 4 таски из tasksData поместились в стейт

let arrayUseState = useState(tasksData)

таска потом удаляется и мы в стейте оставляем только три таски

setTasks(filteredTasks)

И реакт зная что стейт изменился перезапускает функцию App
и он видит опять что мы помещаем 4 таски в useState но useState больше их в себя не помещает
потому что это уже было то есть инициализационного начального значения массива tasksData 
как-будто уже и не происходит

let tasksData = ;

let arrayUseState = useState()

эта часть кода пропускается далее видит useState из useState достаю массив

let arrayUseState = useState()

let useStateTasksData = arrayUseState[0] в этом массиве беру первый элемент
там уже после удаления осталось три таски 

по прежнему получаю функцию которую опять можно вызывать чтобы опять изменять таски

let setTasks = arrayUseState[1]

и иду вниз и отрисовываю опять Todolist и передаю уже три таски туда внутрь

tasksDataApp={useStateTasksData}

<Todolist
    title={'push me'}
    useStateTasksData={useStateTasksData}
    removeTask={removeTask}
/>


_________________________________ Упрощенный пример useState

Создаем функцию Counter (компонент)
который возвращает div в которой находится какое-то значение

function Counter {
    return (
        <div>
        
        </div>
    )
}

это значение мы будем хранить в useState

мы скажем useState изначально ты будешь равен 5

function Counter {
    useState(5) 
    return (
        <div>

        </div>
    )
}

Нам useState возвращает массив 

function Counter {
    let array = useState(5) 
    return (
    <div>
    
    </div>
        )
}

И мы к этой пятерке можем обратиться как к array[0]
array[0] === 5

let data = array[0]

и мы можем эти данные отобразить в div

function Counter {
let array = useState(5)
    return (
        <div>
            {data}
        </div>
        )
}

в index.tsx изменим App на Counter и на странице увидим 5 потому что data = array[0] = 5

Ставим console.log('Counter rendered') чтобы посмотреть сколько раз компонента вызвалась

а значение с которым отрендерилось мы будем видеть в разметке

в логе видим Counter rendered

Реакт вызывает функциональную компоненту Counter 

function Counter {
    let array = useState(5)
    let data = array[0]
    
    return (
        <div>
            {data}
        </div>
    )
}

Реакт вызывает функцию Counter и рисует её, в логе появляется Counter rendered
здесь он внутри видит что мы используем useState - let array = useState(5)

Поэтому он именно для этой отрисовки 5 которую он уже сделал
Он запомнил что конкретно для этого Counter уже есть стартовое значение в дивке и оно равно 5
и его возвращаю назад в массив array чтобы ее можно было отрисовать - data
и отрисовывает

А дальше если вдруг эта 5 будет меняться именно с помощью 
сет функции которая тоже сидит в этом массиве вторым элементом

назовем ее setData (этой переменной можем дать любое имя)

function Counter {
    let array = useState(5)
    let data = array[0]
    let setData = array[1]

    return (
        <div>
            {data}
        </div>
    )
}

Если мы эту функцию вызовем например при клике на саму дивку <div onClick={() => {setData}}>
< onClick={() => {}}> - обработчик события

function Counter {
    let array = useState(5)
    let data = array[0]
    let setData = array[1]

    return (
        <div onClick={() => {setData}}>
            {data}
        </div>
    )
}

и укажем в качестве параметра функции setData() наш первый элемент массива + 1

function Counter {
    let array = useState(5)
    let data = array[0]
    let setData = array[1]

    return (
        <div onClick={() => {setData(data+1)}}>
            {data}
        </div>
    )
}

то у нас при нажатии цифра на странице будет увеличиваться на 1

it works!

_________________________________________________________Explaining

Counter - вызвалась. здесь 5 ->  let data = array[0] === 5
и мы эту пятерку отрисовали 
 <div>{data}</div>

далее мы кликаем <div onClick={() => {setData(data+1)}}></div>

у нас вызывается функция setData
Так как эта setData у нас из массива который из useState -> let setData = array[1] -> let array = useState(5)
То вызов этой {setData(data+1)}} - заставляет изменить данные -> data которые локально относятся к Counter

Соответственно в data для этого Counter в локальном стейте после 1 клика будет - 6
то есть 6 будет в данных

Раз стейт поменялся реакт вызывает функцию опять потому что реакт понимает что от этих данных зависит отрисовка 
то есть эти данные data используются в отрисовке и так как данные используются в отрисовке 
нужно отрисовку получить новую, а чтобы получить новую нужно вызвать функцию Counter

Нужно вызвать эту же функцию Counter для отрисовки Counter реакт ее вызывает и уже хоть в useState
при втором прочтении кода опять передает в параметре 5, 

но теперь когда отрисовка идет второй раз, реакт игнорирует эту 5 
потому что 5 - это было стартовое значение initialState которое реакт уже увеличил до 6 
и он возвращает нам массив в котором сидит 6 -> let data = array[0] -> 6


let array = useState(5)
let data = array[0]      --- второй раз здесь уже 6
let setData = array[1]

и поэтому 6 попадает в <div>{data}</div> и перерисовывается

______________________________________________________________________________________________________________________


То есть jsx зависит теперь от данных которые находятся внутри компоненты useState и от тех которые приходят
в props

В случае с Counter данные в props не приходят и то что мы видим на странице зависит только от данных в локальном стейте

Аналогичная ситуация с App

App не принимает props, поэтому его отрисовка зависит от данных которые находятся в нем в качестве useState
и изменяются в нем же

Но если App вдруг перерисовывается то
перерисовка App заставляет перерисоваться Todolist 

а в Todolist уже попадают данные useStateTasksData={useStateTasksData}

<Todolist
    title={'Benny Benassi'}
    useStateTasksData={useStateTasksData}
    removeTask={removeTask}
/>

Данные которые достаются из массива который возвращает useState

let arrayUseState = useState(tasksData)
let useStateTasksData = arrayUseState[0]
let setTasks = arrayUseState[1]

Но уже эти данные будут изменены относительно initial state
Соответственно эти данные заставляют перерисоваться наш Todolist
____________________________________________________________________________________________________________________

Есть данные из props а есть данные самой компоненты то есть ее локальный стейт и то и то используется для 
отображения jsx разметки

Если есть локальные данные (стейт) то есть и функции которые эти данные может менять в нашем случае useState

Если эта функция вызовется при клике на элемент из jsx разметки то локальные стейт (данные) изменятся
и реакт заново перерисует эту компоненту то есть сама функция-компонента - перезапустится 
и у нас вернется новая jsx разметка

Обычно jsx рисует подкомпоненты относительно компоненты родителя
там находится кнопка которую можно нажать
соответственно сетфункция которая изменяет данные в локальном стейте компоненты родителя
функция которая меняет этот локальный стейт - это первая функция.
вторая функция это которая вызывает первую функцию 

в нашем случае removeTask после filter вызывает функцию setTasks
который меняет непосредственно стейт который был возвращен из useState

То есть мы делаем эту логическую функцию Flogic которая делает какую-то логику
потом получает новые данные и вызывает сетфункцию чтобы эти данные обновили стейт
стейт обновляется компонента перерисовывается

эта функция removeTask обычно вызывается перекидывается в jsx как callback другой компоненте
в нашем случае мы отдале ее Todolist

__________________________________________________________________________________ Ещё раз 

Есть сетфункция setTasks которая меняет данные 
Эта сетфункция вызывается после какой-то логической обработки в нашем случае filter
внутри другой функции в нашем случае removeTask выглядит так:

function removeTask(id: number) {
    let filteredTasksData = useStateTasksData.filter(filteredTask => filteredTask.id !== id)
    setTasks(filteredTasksData)
}

а эта другая функция removeTask отдается как callback другой подкомпоненте

<Todolist
    title={'Benny Benassi'}
    useStateTasksData={useStateTasksData}
    removeTask={removeTask}
/>

и этот callback вызывается в подкомпоненте при клике например на кнопку

<button onClick={() => {props.removeTask(task.id)}}>x</button>

___________________________________________________________________________________

                                                    Рефакторинг
let arrayUseState = useState(tasksData)
let useStateTasksData = arrayUseState[0]
let setTasks = arrayUseState[1]

Доставание элементов из массива и присваивание переменным не очень удобное 

Тоже самое можно сделать короче

Нужно сказать что мы объявляем 2 переменные которые мы хотим получить извлечением элементов из массива, выглядит так:

Было

let arrayUS = useState(tasksData)

let tasksDataUS = arrayUS[0]     --->           let [tasksDataUS, setTasksUS] = arrayUS
let setTasks = arrayUS[1]        --->

Стало

let arrayUS = useState(tasksData)

let [tasksDataUS, setTasksUS] = arrayUS

в массиве arrayUS -> 2 элемента поэтому 1 элемент с данными присвоится tasksDataUS
второй элемент с сетфункцией изменяющей данные из 1-го элемента присвоится setTasksUS

Ещё нам не нужна переменная arrayUS вместо - let arrayUS = useState(tasksData) мы можем написать

let [tasksDataUS, setTasksUS] = useState(tasksData)

Было 

let arrayUS = useState(tasksData)
let [tasksDataUS, setTasksUS] = arrayUS

Стало

let [tasksDataUS, setTasksUS] = useState(tasksData)

Далее избавляемся от переменной tasksData, помещаем все данные сразу в useState

let [tasksDataUS, setTasksUS] = useState([
    {id: 1, title: 'push me', isDone: true },
    {id: 2, title: 'and then just touch me', isDone: true },
    {id: 3, title: 'till i can get my', isDone: true },
    {id: 4, title: 'satisfaction', isDone: true },
])

Учимся фильтровать данные из tasksDataUS через добавление функционала к кнопкам 
All - все 
Active - без галочки не выполненные 
Completed - только те которые с галочками 
находящихся в Todolist

Первым делом учимся делать зависимость разметки от данных 
Чтобы после удаления объекта в массиве объектов вручную на странице это отображалось
Первым делом нужно подумать о том что я при клике на кнопки меняю что-то что влияет на то какие таски передаются

Нам нужно будет хранить какие-то данные
При нажатии на кнопки нам нужно будет менять не массив удаляя и добавляя в него элементы
а менять значение в фильтре 
То есть какой у нас сейчас фильтр All Active либо Completed 
А раз значение меняется и мы хотим чтобы после изменения проиходила отрисовка 
То тогда мы должны использовать useState
И мы useState можем вызывать внутри компоненты многократно
поэтому под 

    let [tasksDataUS, setTasksUS] = useState([
        {id: 1, title: 'push me', isDone: true },
        {id: 2, title: 'and then just touch me', isDone: true },
        {id: 3, title: 'till i can get my', isDone: true },
        {id: 4, title: 'satisfaction', isDone: true },
    ])

пишем 

    let [filter, setFilter]

filter - название переменной которая означает какие данные мы в ней храним  
setFilter - функция с помощью которой мы будем эти сохраненные данные изменять
и которая позволит реакту перерисовать компоненту 

дописываем 

let [filter, setFilter] = useState('all')  -> all значит что после загрузки страницы будут отрисовываться все сразу

И дальше мы можем пустить в Todolist не все таски tasksDataUS

<Todolist title={'Benny Benassi'} tasksDataUS={tasksDataUS} removeTask={removeTask} />

а отфильтрованные таски, выше return в App создадим переменную tasksForTodolist
изначально присвоим сами данные tasksDataUS целиком 

let tasksForTodolist = tasksDataUS

но потом поставим условие, если значение filter = completed то мы в переменную 

tasksForTodolist запишем таски которые отфильтрованы 

if (filter === 'completed') {
    tasksForTodolist = tasksDataUS.filter - помним что фильтр не меняет сам объект tasksData
} фильтр создает новый массив который запишется в tasksForTodolist в который пропускает элементы
которые возвращают true 
И если у одной таски isDone === true то тогда таска попадет в результирующий массив tasksForTodolist
а если у таски - false то есть она не выполненая, значит isDone - false и значит она не попадет в tasksForTodolist

if (filter === 'completed') {
tasksForTodolist = tasksDataUS.filter(task => task.isDone === true) 
}

и далее мы tasksForTodolist прокидываем в атрибут подкомпоненты App - Todolist
Чтобы Todolist получил не все таски а только те таски которые прошли фильтрацию

<Todolist title={'Benny Benassi'} tasksDataUS={tasksForTodolist} removeTask={removeTask} />

И второе условие пропускаем в переменную tasksForTodolist те таски у которых isDone = false
то есть которые не выполнены еще 
и их пропускаем записываем в этот новый массив tasksForTodolist

if (filter === 'active') {
tasksForTodolist = tasksDataUS.filter(task => task.isDone === false)
}

Изначально у нас в стейте all поэтому мы видим все таски
теперь если мы вручную поменяем в useState('all') на completed то увидим только те таски у которых галочка стоит
а если на active то все не выполненые

То есть наша разметка начала подстраиваться под данные 

То есть мы сделали ту самую зависимость в jsx разметке от данных

Осталось сделать так чтобы замена происходила при нажатии на кнопки

1 Делаем разметку
2 Делаем данные 
3 Делаем разметку зависимой от этих данных чтобы меняя данные разметка тоже менялась

Когда мы выстроили такую зависимость потом уже можем делать обработчики события нажатия на кнопки
чтобы при нажатии на что-либо происходило какое-либо действие
Прежде чем мы это будем делать

Мы должны сказать что у нас набор этих фиксированных слов active completed all он ограничен
чтобы не ошибиться
Либо это active либо completed либо all
и для этого мы создадим отдельный тип 
Выйдем за пределы функции и экспортируем типизацию FilterValuesType

и говорим что это либо all либо active либо completed 

type FilterValuesType = 'all' | 'completed' | 'active'

то есть в качестве типа мы берем фиксированные строки 
Далее мы говорим что мы в useState сохраняем наш новый тип FilterValuesType

let [filter, setFilter] = useState<FilterValuesType>('all')

и теперь я не могу ошибиться при задании типа для данного useState а так же в условии if 

if (filter === 'active') 

потому что filter который был возвращен useState

он может быть либо all либо active либо completed 

и мы здесь тоже ошибиться не можем 

Соответственно TypeScript начинает контролировать то чтобы мы не ошиблись

Так же для дополнительного контроля TypeScript мы можем задать дополнительную типизацию
для первого useState

let [tasksDataUS, setTasksUS] = useState<Array<tasksDataUSType>>([

Таким образом мы говорим что у нас массив тасок который мы передаем в useState

Array<tasksDataUSType> - здесь мы уточнили массив
<Array<tasksDataUSType>> - здесь мы уточняем useState

Теперь нам надо менять второй стейт через сетфункцию setFilter
но над этим setFilter у нас есть другая логическая функция которая устанавливает фильтр в зависимости от чего либо

Поэтому мы для этого setFilter создадим функцию которая называется changeFilter

Ту самую логическую функцию 

function changeFilter() {

}

Она будет принимать значение value для нового фильтра это value должно быть обязательно FilterValuesType
то есть или all или complete или active 
function changeFilter(value: FilterValuesType) {

}

и дальше внутри этой функции нужно вызвать setFilter которой передадим value 

function changeFilter(value: FilterValuesType) {
    setFilter(value)
}

Теперь эту функцию changeFilter которая вызываться здесь не будет потому что в App нет кнопок
которые ее будут вызывать
мы эту функцию changeFilter передадим callback в Todolist 
А эти кнопки, они уже сидят в Todolist, они уже вызовут эту функцию когда по кнопкам будет произведен клик

Делаем 

<Todolist
title={'Benny Benassi'}
tasksDataUS={tasksForTodolist}
removeTask={removeTask}
changeFilter={changeFilter}
/>

Вносим её в типизацию 

type TodolistType = {
    title: string
    tasksDataUS: Array<tasksDataUSType>
    removeTask: Function
    changeFiler: Function
}

И дальше мы можем этот changeFilter вызывать например при кликах на кнопки в Todolist

присваиваем onClick кнопке тем самым говорим
кнопка когда по тебе кликнут, ты вызовешь callback функцию а я вызову функцию changeFilter
которая сидит в props и передам ей all в соответствии с названием кнопки

<button onClick={() => {props.changeFilter('all')}}>All</button>
<button onClick={() => {props.changeFilter('active')}}>Active</button>
<button onClick={() => {props.changeFilter('completed')}}>Completed</button>

И теперь будет автоматически вызываться changeFilter который к нам пришел из App в props к Todolist из App
через атрибут Todolist 
changeFilter в свою очередь получает значение value и передает его в setFilter
setFilter приходит из useState из хука поэтому стейт меняется и компонента заново вызывается чтобы 
перерисоваться с новыми данными 
срабатывает новая фильтрация и только те таски что нужно попадают в todolist

Но мы не протипизировали значение которые мы указали в 

<button onClick={() => {props.changeFilter('all')}}>All</button>
<button onClick={() => {props.changeFilter('active')}}>Active</button>
<button onClick={() => {props.changeFilter('completed')}}>Completed</button>

all active completed

мы указали что функция просто Function в типизации выше 

type TodolistType = {
    title: string
    tasksDataUS: Array<tasksDataUSType>
    removeTask: Function
    changeFilter: Function
}

это неверно, это значит какая угодно функция, то есть мы могли вообще ничего не передавать и TS не ругается

<button onClick={() => {props.changeFilter('')}}>All</button>
<button onClick={() => {props.changeFilter('')}}>Active</button>
<button onClick={() => {props.changeFilter('')}}>Completed</button>

Для этого мы пишем в типизации 

changeFilter: (value: FilterValuesType) => void

что функция принимает value которое затипизировано FilterValuesType и возвращает void то есть ничего
после => указываем что эта функция возвращает void - ничего не возвращает

(value: FilterValuesType) - а здесь пишем что функция принимает

аналогично для removeTask

removeTask: (id: number) => void

всё 

it works!

Итоги

У нас есть компонента App которая передает внутри себя отрисовывает компоненту Todolist 
В Todolist App передает какие-то данные 
так происходит потому что Todolistов затем мы можем отрисовать много
Каждый Todolist должен быть уникальным поэтому каждый Todolist получает на входе данные 
в виде атрибутов они оже объект props которые надо типизировать чтобы все не пошло крахом 
Мы не можем передавать какие хочешь props для этого нам нужна типизация
Чтобы мы четко пользовались и передавали в Todolist четко именно то что он ждет 

Компонента принимает props для того чтобы 
1 среди этих props есть данные, а есть callback, благодаря тому что мы в компоненту можем засунуть и данные и callback
эта компонента может реагировать и вести себя по разному 
получая разные данные в виде атрибутов компонента может их по разному отрисовывать
один и тот же Todolist нарисовала разные title и разные данные а во вторых получая callback 
компонента может вести себя по другому 
запуская наши callback removeTask changeFilter
и мы их передаем в качестве аргументов 

Если Todolist было бы два, функции changeFilter и removeTask тоже было бы по две

То есть мы извне задаем как себя вести компоненте Todolist
говорим что она должна отрисовать какие данные и что ты должен вызвать когда у тебя там 
что-то внутри произойдет 
потому что мы тут снаружи можем управлять тем что ты нам передашь
потому что данные хранятся в App а там где хранятся данные должны храниться и функции которые эти данные меняют

Задача Todolist отрисовать что ему дали и его задача сообщить наверх вызвав callback которые мы передали 
в качестве функций changeFilter и removeTask в качестве аргументов - сообщить наверх о том
что какое-то действие хочет совершиться с той частью jsx разметки которую мы передали в Todolist

Соотв мы передаем эти callback в виде функций changeFilter и removeTask а дальше 
есть только Todolist который просто принимает props 

непереводимый итальянский фольклёр

Если мы удалим содержимое функции removetask то Todolist как отрисовывал все что ему приходило
так и будет это делать 

Все решают данные либо компонента в которой они хранятся

Аналогично с фильтрацией

____________________________________________ Todolist lesson 3 

Добавляем библиотеку yarn add uuid
и типизацию к ней yarn add @types/uuid

Далее мы можем пользоваться функциями которые из этой библиотеки экспортируются

Для нас интересна основная функция это v1()

при вызове она нам генерирует уникальный id

let tasks = [
    {id: v1(), title: 'push me', isDone: true },
    {id: v1(), title: 'and then just touch me', isDone: true },
    {id: v1(), title: 'till i can get my', isDone: false },
    {id: v1(), title: 'satisfaction', isDone: false },
]

У нас ранее id использовался порядковый номер от 1 и вверх
в реальной жизни id занимается backend

есть формат uuid - universally unique identifier 
есть формат guid - global unit identificator

Дают нам уникальные id с микроскопической вероятностью совпадения между собой 

Пока мы работаем только на фронте не взаимодействуя с backend то нам нужно взять генерацию id на себя

Заменяем порядковые номера id в тасках на функцию v1()

импортируем функцию v1() и заменяем тип id с number на string потому что v1() выдает тип данных string

Вот так выглядят id созданные функцией v1()

0:{id: '603a8144-8cf0-11ed-8761-4968691f6ece', title: 'push me', isDone: true}
1:{id: '603a8145-8cf0-11ed-8761-4968691f6ece', title: 'and then just touch me', isDone: true}
2:{id: '603a8146-8cf0-11ed-8761-4968691f6ece', title: 'till i can get my', isDone: false}
3:{id: '603a8147-8cf0-11ed-8761-4968691f6ece', title: 'satisfaction', isDone: false}
length:4

______________________________ к прошлому уроку по поводу map

Реакту важно знать что именно удаляется
а у нас была функция removeTask которая удаляла таску
map нужен key 

Всегда когда мы mapим когда мы сопоставляем какой-то jsx элемент или компонент
к какому либо объекту (в нашем случае массиву объектов) 
Нам важно связать этот jsx элемент с этим объектом и как правило 
У этого объекта на основании которого мы создаем jsx разметку в нашем случае li
Всегда должно быть id 
Если id нет с осторожностью можно использовать второй параметр который приходит в callback
индекс 

key

props.tasksForTodolist.map((task, index) =>
<li key={task.id}>
    <input type="checkbox" defaultChecked={task.isDone}/>
    <span>{task.title}</span>
    <button onClick={() => {props.removeTask(task.id)}} className={'deleteButton'}>x</button>
</li>

index

props.tasksForTodolist.map((task, index) =>
<li key={index}>
    <input type="checkbox" defaultChecked={task.isDone}/>
    <span>{task.title}</span>
    <button onClick={() => {props.removeTask(task.id)}} className={'deleteButton'}>x</button>
</li>

с осторожностью потому что если вдруг с этим массивом происходят изменения (удаление)
меняется порядок отображения элементов то могут быть проблемы поэтому обязательно
передаем атрибут key элементу родителю jsx разметки внутри map

________________________________________________________________

Учимся добавлять таску в массив после нажатия на кнопку + в Todolist 

Для того чтобы изменять таски таким образом чтобы реакт на это реагировал и делал перерисовку 
у нас есть в функции useState функция setTasksUS

tasksDataUS - является чем-то что находится в локальном стейте в качестве initail state 
который с помощью hook реактом контролируется 
и если мы эти tasksDataUS будем менять с помощью функции setTasksUS то реакт будет перерисовывать компоненту App
а за ее перерисовкой последует и перерисовка Todolist 

в данный момент setTasksUS используется в функции removeTask во время удаления таски

function removeTask(id: string) {
    let filteredTasksDataUS = tasksDataUS.filter(filteredTask => filteredTask.id !== id)
    setTasksUS(filteredTasksDataUS)
}

Но мы так же будет этот setTasksUS вызывать во время добавляения таски

function addTasks() {
    
}

Чтобы добавить таску мы должны сгенерировать новый объект таски и добавить в него стандартную начинку

function addTasks() {
    let newTask = {id: v1(), title: 'New Task', isDone: false}
}

Дальше нам нужно взять массив который был tasksDataUS и сформировать новый массив

По правилу immutable мы не имеем права модифицировать тот массив который к нам пришел
мы могли бы в этот массив запушть новый объект tasksDataUS.push() но этого делать нельзя
потому что мы таким образом модифицируем тот объект который у нас был

В Функциональном программировании это не правильно, мы не имеем права модифицировать изначальные данные

Нам нужно получить новый массив в который добавилась таска
для этого нам нужно

Создать новый массив тасок let newTasks = добавляем одну таску в начало [newTask]
а в конец записываем все те элементы, таски которые сидели в старом массиве таскс [newTask, tasksDataUS]

function addTasks() {
    let newTask = {id: v1(), title: 'New Task', isDone: false}
    let newTasks = [newTask, tasksDataUS]
}

Если мы напишем так то во втором элементе будет находиться отдельный массив с тасками поэтому нам нужно
из массива tasksDataUS достать все элементы 
Данная операция называется деструктуризация массива [...tasksDataUS] поэтому 

function addTasks() {
    let newTask = {id: v1(), title: 'New Task', isDone: false}
    let newTasks = [newTask, ...tasksDataUS]
}

Таким образом мы создали новый массив первым элементом положили новый объект а последним элементом
достали все объекты из старого массива, таким образом в новом массиве мы собрали все таски
и новые и старые без изменения старого массива
то есть мы создали новый объект newTasks

И теперь если мы этот новый объект закинем в функцию setTasksUS
которую мы уже вызывали в функции removeTask там в качестве аргумента мы указывали setTasksUS(filteredTasksDataUS)
а здесь в качестве параметра помещаем новый массив с добавленной новой таской

function addTasks() {
    let newTask = {id: v1(), title: 'New Task', isDone: false}
    let newTasks = [newTask, ...tasksDataUS]
    setTasksUS(newTasks)
}


То есть у нас есть компонент, в нем есть стейт - tasksUS
и есть функция которые эти данные может изменять setTasksUS что приведет к перерисовке

и вокруг этого setTasksUS мы строим другие функции, удаления, добавления
Прописываем какую-то логику а потом вызываем setTasksUS

function addTask() {
    let newTask = {id: v1(), title: 'New Task', isDone: false}
    let newTasks = [newTask, ...tasksUS]
    setTasksUS(newTasks)
}

function removeTask(id: string) {
let filteredTasksDataUS = tasksUS.filter(filteredTask => filteredTask.id !== id)
setTasksUS(filteredTasksDataUS)
}

а эти две функции addTask removeTask они вызываются не в этой же компоненте, потому что
данные хранятся там же где и эти функции, 
а ui который вызывает эти функции как правило хранится уже в подкомпоненте

и мы эти две функции прокидываем через props через функции callback в наш Todolist 
В Todolistе наши функции вызовутся, а активируются в App потому что они находятся в App 
мы их просто передали по ссылке в Todolist чтобы там их можно было вызвать по нажатию на кнопки
и наши функции изменят стейт через функцию setTasksUS 
стейт перерисуется и перерисуется Todolist 

Поэтому передаем нашу функцию addTask в Todolist через атрибут Todolist 

addTask={addTask} - без скобок addTask={addTask()} - addTask() - это значит что я сразу вызываю функцию addTask
Так мы попадем в бесконечный цикл
_________________________________________ бесконечный цикл
function addTask() {
    let newTask = {id: v1(), title: 'New Task', isDone: false}
    let newTasks = [newTask, ...tasksUS]
    setTasksUS(newTasks)
}

addTask()
__________________________________________
<Todolist
    title={'Benny Benassi'}
    tasksForTodolist={tasksForTodolist}
    removeTask={removeTask}
    addTask={addTask}
    changeFilter={changeFilter}
/>

Добавляем addTask в типизацию props

type TodolistType = {
    title: string
    tasksForTodolist: Array<tasksForTodolistType>
    removeTask: (id: string) => void
    changeFilter: (value: FilterValuesType) => void
    addTask: () => void
}

поэтому важно в качестве callback addTask={addTask} в подкомпоненту отдавать название функции без скобок

Теперь компонента Todolist получает в props нашу функцию addTask и можем ее вызвать

Сделаем так чтобы вызов этой функции происходил после нажатия на кнопку button 

<button onClick={ () => {props.addTask()} }>+</button>

уже в Todolist мы указываем функцию addTask() со скобками чтобы она вызвалась и запустила цепочку добавления
таски в новый массив

Вызовется функция addTask создастся новая таска newTask создастся новый массив в который добавится newTask
и все предыдущие таски
и этот массив через сет функцию изменит наш initial state и с помощтю хука заставит реакт отрисовать страницу еще раз
но уже с новыми данными с добавленной таской
setTasksUS(newTasks) 

На данный момент на странице при нажатии на + добавляется новая таска с названием New Task и есть
возможность ее удалить

___ Далее, нам хочется чтобы значение которое мы вводили в поле ввода и было в title нашей новой new task
поэтому первое что нам нужно будет сделать это, это самое значение из inputa как-то прочитать

Любой элемент в который мы можем вводить текст на странице может быть контролируемым или не контролируемым
Контролируемый инпут это когда мы ему строго задали value которое в него введено или может быть введено

Если мы инпуту задали value = 5 то значит там будет жестко задано 5

Или если мы инпуту зададим value = 'hello' мы увидим что мы ничего дополнительно ввести не можем
а так же не можем удалить символы заданного значения 
потому что мы жестко задали значение для инпута 

что делать

Укажем вместо 5 переменную из стейта который мы сделаем в этой же компоненте 
назовем эту переменную v и дальше когда мы будем пытаться впечатать символ в 
input value={v} - у нас символ не сможет впечататься потому что v было равно 'ilai'
у нас этот 'ilai' не показыватся но когда мы будем пытаться впечатывать 
будет срабатывать событие change и мы на него можем подписаться с помощью 
onChange то есть мы будем видеть попытку инпута изменить значение 
в этой попытке мы будем видеть допечатанный символ например
ilai ! то есть добавится ! 
мы это ilai ! отправим в стейт это ilai ! появится в стейте 
а раз v изменится в стейте значит новое v попадет в value и инпут сможет отрисовать это значение 
мы печатаем новый символ он в onChange пытается сообщить нам что я пытаюсь напечататься 
мы это новое значение например ? знак отправляем в стейт
так как стейт изменился перерисовка происходит и это новое значение приходит в value и мы видим это значение
такой круговорот
flux круговорот

это значение которое вводится в ingut я сохранять буду с помощью useState не в App компоненте 
а в Todolist потому что задача стейта Todolist контролировать инпут и чтобы потом из этого стейта 
можно было напечатанное значение прочитать нажам на кнопку + 

Контроль инпута нам нужен для того чтобы прочитать а что было введено
первичны данные потом отрисовывается инпут 
мы пытаемся что-то вводить, мы эту попытку фиксируем в стейте
а потом только перерисуется картинка 

и благодаря этому можем во время нажатия на кнопку 
обратиться к этому значению в стейте и его отправить в компоненту App 
чтобы оно добавилось в объект tasksUS и там было отрисовано

Но пока мы его впечатываем и не нажали на + 
Это значение оно является достоянием локального тудулиста 
поэтому мы локальный стейте делаем у тудулиста свой 

useState - локальный стейт - может быть у любой компоненты просто App компонента она самая верхняя
высокоуровневая поэтому мы ее нагрузили хранить таски

А значение которое впечатывается в инпут это уже не бизнес данные 
это просто значение которое впечатывается оно как впечатывалось так может и удалиться 

Если мы не нажали на + оно не станет частью бизнеса 
Соответственно это локальный стейт который сама таска будет контролировать 

Поэтому мы идем и в Todolist добавляем useState 
и говорим храним значение для title
изначально там пустая строка поэтому 
useState('')
импортируем useState

export function Todolist(props: TodolistType) {
    useState('')

    return 
}
и с лева от useState 

    let [inputTitle, setInputTitle] = useState('')

inputTitle - даем название нашей переменной которую мы впишем в поле инпут 
которая будет отражать что там хранится и сетфукнция для этой переменной которая будет ее изменять

и мы говорим что inputTitle (значение которой изначально пустая строка) мы присваиваем 
к атрибуту value тега инпут
так как мы хотим прочитать значение из переменной ставим фигурные скобки 

<input value=/>

export function Todolist(props: TodolistType) {
let [inputTitle, setInputTitle] = useState('')

    return (
        <div>
            <h3>{props.title}</h3>
            <div>
                <input value={inputTitle}/>

После этого мы увидим в инпуте инициализационное значение из useState 
а именно пустую строку, но ничего напечатать в инпут мы так и не можем 
потому что мы так же жестко задали value для input
а жестко он задан потому что inputTitle не меняется
потому что мы не воспользовались функцией setInputTitle

Поэтому мы будем вызывать setInputTitle и записывать в него то значение 
которые впечатывается в input 
когда идет попытка изменить значение инпут, то есть сделать инпуту change
срабатывает событие change 
и мы можем добавить в инпут атрибут onChange 
а в него повесить обработчик () => {} на событие onChange

<input value={inputTitle} onChange={ () => {} }/>

то есть мы говорим - инпут когда ты пытаешься меняться вызывай нашу функцию onChange={ () => {} }
и внутри этой функции мы должны засетать новое значение setInputTitle
то есть отправить это новое впечатанное значение в стейт с помощью функции setInputTitle

допустим новым значением будет sd, итого

<input value={inputTitle} onChange={ () => {setInputTitle('sd')} }/>

после этого при нажатии на любую клавишу в поле на странице появляется sd 

Так происходит потому что я пытаюсь изменить значение инпута впечатывая текст в поле на странице
инпут запускает функцию onChange а в этой функции onChange мы говорим реакту
чтобы он установил в качестве значения переменной inputTitle - 'sd'

'sd' - устанавливается компонента перерисовывается и это sd попадает в value 
а дальше я пытаюсь впечатать что-то но мы постоянно говорим sd sd sd 
поэтому всегда рисуется sd

Поэтому как параметр функции setInputTitle мы должны передавать не функцию sd 
а то на что пытается поменяться таска 
то есть на то что в инпуте впечатано в момент события onChange

и это значение которое появляется в момент изменения change в инпуте 
мы можем получить с помощью объекта-событие 

в любое событие, клик происходит или onChange 
всегда попадает объект, который обычно называют e 

мы его не использовали ранее на all active completed потому что он не был нужен

<button onClick={(e) => {props.changeFilter('all')}}>All</button>
<button onClick={(e) => {props.changeFilter('active')}}>Active</button>
<button onClick={(e) => {props.changeFilter('completed')}}>Completed</button>

но сейчас

<input value={inputTitle} onChange={ (е) => {setInputTitle('sd')} }/>

но сейчас он нам нужен потому что в этом объекте e сидит вся информация 
о произошедшем событии 
но нас не интересует вся информация 
нас интересует в этом e, непосредственно виновник события
то есть с каким элементом произошло событие, а именно

e.currentTarget

то есть в e.currentTarget это элемент с которым произошло событие 
элемент на изменения в котором мы и подписались 
который упаковывает для нас впечатываемое значение в инпуте 

и мы можем обратиться таким образом к инпуту и взять его текущее value 
которое появляется когда мы впечатываем текст, то есть

e.currentTarget.value

и мы это value отправляем в локальный стейт

return (
    <div>
        <h3>{props.title}</h3>
        <div>
            <input value={inputTitle} onChange={ (e) =>
            {setInputTitle(e.currentTarget.value)}}/>
            <button onClick={ () => {props.addTask()} }>+</button>
        </div>

соотв это value впечатается, изменяет стейт установив новое значение для переменной inputTitle
и потом приходит обратно <input value={inputTitle} и отрисуется

теперь после того как мы завершили ввод наименования новой таски в поле инпут
и в момент того как мы нажимаем на кнопку +
мы можем прочитать, взять это значение inputTitle потому что оно засихронизировано 
с инпутом 
то есть то что у нас хранится в стейте в переменной inputTitle оно же и отображается в инпут 
и при попытке измениться это все как-то синхронизируется, соответственно
у нас что в стейте что в инпуте одно и то же значение 
поэтому мы можем им воспользоваться внутри функции addTask

как мы им воспользуемся, мы можем передать это значение впечатываемое в инпут
в качестве параметра в функцию addTask

<button onClick={ () => {props.addTask(inputTitle)} }>+</button>

это значит что в App это впечатываемое значение придет в функцию addTask в App в качестве того же 
параметра 

задаем название для этого параметра в App и пишем его типизацию

function addTask(title: string) {}

а также указываем в типизации TodolistType - addTask: (title: string) => void

type TodolistType = {
    title: string
    tasksForTodolist: Array<tasksForTodolistType>
    removeTask: (id: string) => void
    changeFilter: (value: FilterValuesType) => void
    addTask: (title: string) => void
}

и дальше мы можем этим title воспользоваться когда структурируем, собираем новый объект
и сказать

function addTask(inputTitle: string) {
    let newTask = {id: v1(), title: inputTitle, isDone: false}
    let newTasks = [newTask, ...tasksUS]
    setTasksUS(newTasks)
}

Что title будет не 'New Task' а будет то значение которое к нам придет в параметре

и дальше мы этот объект newTask закидываем в массив 

После этого впечатываемое значение в инпут после нажатия на + 
будет добавляться на страницу в качестве отдельного пункта списка тасок 

_________________ Далее после добавления нам хочется чтобы значение очищалось

Наша задача очистить значение в стейте 
вызвав setInputTitle после нажатия по кнопке и задав туда пустую строку

<button onClick={ () => {
    props.addTask(inputTitle)
    setInputTitle('')
} }>+</button>

таким образом и команда на отрисовку в функцию уйдет, и новое значение setInputTitle
заставит опять перерисоваться inputTitle то есть стейт на пустую строку 

и в инпут  

<input value={inputTitle} onChange={ (e) => {setInputTitle(e.currentTarget.value)}}/>

приходит пустое значение 

________________ Делаем так чтобы при нажатии на Enter таска добавлялась на страницу

Есть много событий которые происходят с элементом 

Для начала мы должны понять с каким элементом происходит событие нажатия на клавишу Enter

c инпутом 

то есть мы нажимаем enter находясь в инпуте после впечатывание текста,
значит и событие происходит с инпутом 

ищем этот инпут, видим что мы у инпута дали value и onChange

<input value={inputTitle} onChange={ (e) =>{setInputTitle(e.currentTarget.value)}}/>

соотв мы можем реагировать на разные события 

Если мы поставим on там где можно вписать атрибут для input 
мы увидим в подсказках много других событий 

onClick
onBlur - это когда фокус уходит из элемента 
onKeyPress - это то что нам надо клавиша нажата и отпущена вверх
onKeyDown - когда клавиша нажата но не отпущена вверх
onKeyUp - когда клавиша была поднята 

еще есть возможно считать сколько времени прошло после этих событий 

onKeyPress - это то что объединяет onKeyDown и onKeyUp
то есть если произошел onKeyDown onKeyUp это значит что произошел и onKeyPress

и мы говорим когда произойдет нажатие клавиши вызови нашу функцию 
добавляем событие event 

<input value={inputTitle}
    onChange={ (e) => {
    setInputTitle(e.currentTarget.value)
    }}
    onKeyPress={(e) => {}}
/>

Нам надо в этом объекте e достать кнопку которая была нажата
Для этого через debugger определяем свойство charCode у той клавиши которая была нажата 

altKey:false
bubbles:true
cancelable:true
charCode:13
code:"Enter"
keyCode: всегда 0 на любой клавише
charCode:13

13 - значение клавиши Enter 

Пишем условие в callback функции onKeyPress

if (e.charCode === 13) {

}

если условия верно то выполняем тот же код который мы волняли для кнопки + 
когда добавляли таску

if (e.charCode === 13) {
    props.addTask(inputTitle)
    setInputTitle('')
}

В результате после написания текста в поле инпут и нажатия клавиши Enter код добавляется
на страницу 

То есть мы делаем одно и то же действие что при нажатии на кнопку enter что при нажатии на + 

Сделаем интереснее и объявим что новая таска будет добавляться с помощью сочетания клавиш
ctrl + enter

if (e.ctrlKey && e.charCode === 13)

теперь таска добавляется только при сочетании клавиш ctrl + enter

_______________________________ Рефакторигн Todolist 

Рефакторинг это изменение структуры кода без изменения поведения программы 
Рефакторинг нужен для того чтобы человек который читает программму лучше в ней ориентровался

Любой дурак может написать программу для машины, но далеко не каждый может написать программу для людей

1. Выносим все функции которые у нас используются в Todolist необходимо вынести над return
присвоить переменным и после return пользоваться ими как переменными

первый атрибут инпуn который будем рефакторить - onChange

let onNewTitleChangeHandler = (e) => {
    setInputTitle(e.currentTarget.value)
}

указываем название переменной в место функции в коде ниже, без скобок

onChange={onNewTitleChangeHandler()} - не правильно
onChange={onNewTitleChangeHandler} - правильно

потому что инпут сам вызовет эту функцию когда будет нужно

но

let onNewTitleChangeHandler = (e) => {
    setInputTitle(e.currentTarget.value)
}

здесь e - event подчеркнется красным потому что для typescript его тип уже задан не так явно
чем когда эта функция была задана в качестве callback в атрибуте инпут

Поэтому чтобы узнать какая типизация устроит typescript 
мы задаем для e явно не правильную типизацию e: number
после чего смотрим на ошибки и в подсказках видим какую типизацию нужно указать для данного события event
и получаем

let onNewTitleChangeHandler = (e: ChangeEvent<HTMLInputElement>) => {
    setInputTitle(e.currentTarget.value)
}

таким образом typescript помогает мне задать правильную типизацию

Не забываем импортировать новую типизацию из react

тоже самое для onKeyPress

let onKeyPressHandler = (e: KeyboardEvent<HTMLInputElement> ) => {
    if (e.ctrlKey && e.charCode === 13) {
    props.addTask(inputTitle)
    setInputTitle('')
    }
}

onKeyPress={onKeyPressHandler}

Если предлагает импортировать из dom или из react выбираем react

далее рефакторим button onClick

let addTask =  () => {
    props.addTask(inputTitle)
    setInputTitle('')
}

return (

<button onClick={addTask}>+</button>

то же самое для фильтров all active completed

const onAllClickHandler = () => {props.changeFilter('all')}
const onActiveClickHandler = () => {props.changeFilter('active')}
const onCompletedClickHandler = () => {props.changeFilter('completed')}

<button onClick={onAllClickHandler}>All</button>
<button onClick={onActiveClickHandler}>Active</button>
<button onClick={onCompletedClickHandler}>Completed</button>

рефакторим map

Функция удаления removeTask - не общая для всего Todolist 
Функция удаления своя у каждой li
Каждая li генерится map
map вызывает стрелочную функцию внутри этой стрелочной функции мы передаем функцию callback 
которую передаем каждой кнопке в отдельности
то есть у нас много кнопок х и у каждой кнопки х свой callback 
поэтому мы не можем вынести наверх 1 callback который подойдет всем 
у каждой кнопки он свой 
поэтому чтобы вынести таким же образом из map нам нужно добавить в 

{
    props.tasksForTodolist.map((task) =>
    <li key={task.id}>
    <input type="checkbox" defaultChecked={task.isDone}/>
    <span>{task.title}</span>
    <button onClick={() => {props.removeTask(task.id)}} className={'deleteButton'}>x</button>
    </li>
    )
}

->

{
props.tasksForTodolist.map((task) => {

const onRemoveHandler = () => {
    props.removeTask(task.id)
}

return (
    <li key={task.id}>
        <input type="checkbox" defaultChecked={task.isDone}/>
        <span>{task.title}</span>
        <button onClick={onRemoveHandler} className={'deleteButton'}>x
        </button>
    </li>
)
})
}

Итог 

Наш стейт идеологически (не технически) - делится на 2 стейта 

Bll state                                  UI state

business - то о чем приложение, какая у него бизнес логика 
бизнес логика означает - какая предметная область, о чем это приложение 

business state в больших приложениях управляется редаксом 

В проекте Todolist стейтом управляет App копмонент и его локальный useState 
который в реакте позволяет управлять стейтом, локальный хук useState 
который управляет business state 
Тут же у нас появляется под компонента Todolist и у него тоже появляется аналогичный useState 
Он нам нужен для того чтобы контролировать то значение которое у нас появляется в инпуте 

Ничто визуально не может измениться на страничке если у нас не поменялись данные 
поэтому мы сначала изменяем данные, измененные данные уже попадают в инпут
если мы пытаемся что-то ввести в инпут то изменяем данные в стейте и только после этого
они попадают в инпут flux круговорот 

этот локальный стейт todolist понадобился чтобы управлять инпутом 
и этот локальный стейт (данные которые находятся в нем) они не должны выходить в App
компоненту потому что это еще не business логика 
а вот когда мы нажмем на + тогда эти данные уже будут влиять на отрисовку 

___________________________________________ Todolist lesson 4

Проектом папку делаем файл package.json в котором указаны все зависомости 
и библиотеки которые использовались в проекте

Webpack - сборщик, программа которая начинает анализировать файлы проекта, 
все импорты экспорты из разных файлов собирает в один файл

Далее Webpack запускает различные программы например Babel 
с помощью которого webpack траспилирует весь jsx в js потому что браузер
может воспринимать только js

Babel не может отправить в браузер ни TS ни JSX 

jsx - js - транспилирование 
ts - js - компилирование 

и этот js уже попадает в браузер
Но чтобы js попал в браузер он может быть загружен только в качестве html странички
js - только через html

а как index.html попадает в браузер? Его нам должен отправить сервер

Мы не запускаем файл через файловую систему, мы index.html запускаем через 
localhost: порт 3000

так вот localhost это доменное имя моего пк, чтобы мой пк мог обратиться к самому себе
Соответственно у меня на пк должен запуститься сервер, программа, backend сервер,
который мне этот index.html отдаст 

и когда мы пишем yarn start 
в проекте компилируется jsx - js ts - js 
webpack - поднимает сервер на localhost: 3000 на 3000 порту 
и этот localhost загружается в браузере 
и этот localhost сервер отдает браузеру html
потом следом за html подтягиваются jsrciptы
и запускается приложение 

Чтобы все эти процессы происходили это все уже настроено в 
create react app само по себе

то есть create react app это совокупность настроенных модулей

После открытия проекта без папки node_modules в webstorm, программа проанализирует
файл package.json и предложит установить недостающие зависимости yarn
но даже после этого могут подчеркиваться красным пакеты которые были доустановлены

Подсветку красным цветом делает webstorm но он это делает на основе webpack
typescript компилятора анализатора, то есть не мгновенно, поэтому даже после такой установки всех пакетов
пакеты которые были установлены могут отображаться как не установленные и подчеркиваться красным

Для удаления подобных красных подчеркиваний, можно заново прописать импорт пакета,
либо закрыть webstorm и открыть его заново

___ Делаем так чтобы на checkbox todolistа можно было поставить галочку и убрать ее
то есть изменять значение isDone с true на false и наоборот

В данный момент они у нас не изменяются потому что мы в jsx разметке жестко задали свойство checked
то есть наш checkbox не будет реагировать на onChange и не сможет измениться 

Так как мы задали checked intput стал контролируемым 
Если бы мы его не задавали то input был бы не контролируемым и можно было бы ставить и убирать галочку
но нам это не подходит потому что чаще всего мы хотим контролировать значение которое там находится

Но чтобы значение было контролируемым, свойство isDone должно иметь возможность меняться
isDone это свойство которое находится в объекте task, который мы получаем в результате 
использования метода массива map в отношении данных tasksUS из App
которые приходят в Todolist из App в props 

То есть чтобы в <input type="checkbox" defaultChecked={task.isDone}/> в Todolist 
поменять значение checkbox нужно поменять значение объекта в tasksUS в App

Так как мы знаем что объект tasksUS хранится у нас в App компоненте в локальном стейте 
с помощью хука useState соответственно функция которая будет менять этот объект 
тоже будет находиться в App
Создадим такую функцию

function changeStatus() {

}

Нам надо найти нужную таску и ей поменять свойство isDone 

1 нужно добавить в функцию все таски которые у нас находятся в локальном стейте
в переменной tasks
переменная лежит за пределами функции, и функция может к ней обратиться это называется замыкание
когда внутри функции нет переменной к которой обращается функция но эта перменная есть за 
пределами функции

2 с помощью метода find находим нужную task по id 
find так же принимает callback 

function changeStatus() {
    tasksUS.find(() => {})
}

каждый элемент таски для которого этот callback будет вызываться 
каждая таска будет приходить внутрь стрелочной функции как параметр task

function changeStatus() {
    tasksUS.find((task) => {})
} - напоминает фильтр и map

Дальше наша функция должна вернуть true 
Если функция вернет true то тогда эта таска и будет считаться найденой и она и запишется
в переменную taskCS

function changeStatus() {
   let taskCS = tasksUS.find((task) => {true})
}

А true мы должны вернуть из этой функции 
если у нас task.id (те id по которым пробегается find) будет равна той таске
которую нам надо поменять некое taskId

function changeStatus() {
    tasksUS.find((task) => {
        if (task.id === taskId) {
            return true
        } else {
            return false
        }
    }) 
}

or 

function changeStatus() {
    let taskCS = tasksUS.find((task) => task.id === taskId)
}

Какое именно taskId нам нужно, то которое надо изменить

Соответственно мы должны обеспечить нашу функцию соответствующим параметром taskId
Тот кто вызовет функцию changeStatus должен будет передать этот параметр в функцию 

function changeStatus(taskId: string) {
    let taskCS = tasksUS.find((task) => task.id === taskId)
}

таким образом найдем нужную таску 

Еще не много рефакторинга 


function changeStatus(taskId: string) {
    let taskCS = tasksUS.find(task => task.id === taskId)
}

таким образом функция нам говорит, что она в tasksUS ищет таску чей id совпадет с taskId
и когда находит помещает его в переменную taskCS и перестанет искать

Найдя эту таску мы будем менять значение ее свойства isDone на противоположное
с true на false с false на true 

Для этого 

let a = true 
let b = !a
b = false
если сказать что b = !b то 
b будеn равно true

То есть ! не a меняет значение b на противоположное, что нам и нужно

поэтому в функции пишем 

function changeStatus(taskId: string) {
    let taskCS = tasksUS.find(task => task.id === taskId)
    task.isDone = !task.isDone
}

Дополнительно протипизируем значение isDone 

function changeStatus(taskId: string, isDone: boolean) {
    let taskCS = tasksUS.find(task => task.id === taskId)
    task.isDone = !task.isDone
}

Применим это значение isDone в функции 

function changeStatus(taskId: string, isDone: boolean) {
    let taskCS = tasksUS.find(task => task.id === taskId)
    tasksCS.isDone = isDone
}

tasksCS - подчеркивается красным, потому что возможно ситуация при которой tasksCS попадет 
undefined и появится ошибка, поэтому мы должны поставить дополнительное условие

Если таска существует то тогда свойство isDone этой таски поменять на противоположный

function changeStatus(taskId: string, isDone: boolean) {
    let tasksCS = tasksUS.find((task) => task.id === taskId)
    if(tasksCS) {
    tasksCS.isDone = isDone
    }
}

if(tasksCS) - псведо истина, Если таска существует то
______________________________________________________ Psevdo
Псевдоистина и псевдоложь в Javascript это значения, по факту не являющиеся true и false, 
но принимаемые за true и false в условных выражениях.

То есть псевдоистина и псевдоложь с одной стороны не являются булевыми значениями, 
но именно в условных выражениях ведут себя как булевые.

В Javascript сущестует 5 псевдоложных значений: (остальные - псевдоистинные).

undefined
null
0
пустая строка
NaN


if(test_1 == true){
console.log(true)}
else{


/*undefined - неопределенная переменная */
var test_1;
if(test_1 == true){
console.log(true)}
else{
console.log(false)}

/* null - несуществующий объект */
var test_2 = document.getElementById("id");
if(test_2){
console.log(true)}
else{
console.log(false)}

/* ноль */
if(0){
console.log(true)}
else{
console.log(false)}

/* пустая строка */
if(""){
console.log(true)}
else{
console.log(false)}

/* NaN - не число*/
if(NaN){
console.log(true)}
else{
console.log(false)}

________________________________________________

Таску мы изменили (изменив isDone) 

Но чтобы изменить перерисовку мы должны вызвать setTasksUS
Все таски находятся в массиве и нужно реакту сказать что в массиве в одной таске произошли
изменения и их необходимо отрисовать 

И так как мы в качестве useState изменяем массив нам нужно передать в сет функцию массив 
с этими изменениями

и прокинем функцию changeStatus к инпуту через props и будем ее вызывать в инпуте
когда там будет происходить событие onchange

onChange срабатывает когда поле ввода пытается изменить значение
добавим checkboxу событие onChange и добавим обработчик 
Обработчик создаем рядом с другими
Наша задача связать попытку изменния чек бокса с вызовом нашей функции changeStatus
в App

function changeStatus(taskId: string, isDone: boolean) {
    let tasksCS = tasksUS.find((task) => task.id === taskId)
    if(tasksCS) {
    tasksCS.isDone = isDone
    }
    setTasksUS(tasksUS)
}

<input type="checkbox" onChange={onCheckboxChangeHandler}

const onCheckboxChangeHandler = () => {

} 

таких функций будет много, для каждого чек бокса своя 
Поэтому эту функцию мы должны объявить внутри функции map 

{
    props.tasksForTodolist.map((task) => {
        const onRemoveHandler = () => {
            props.removeTask(task.id)
        }
        const onCheckboxChangeHandler = () => {

        }
        return (
            <li key={task.id}>
                <input type="checkbox" onChange={onCheckboxChangeHandler} defaultChecked={task.isDone}/>
                <span>{task.title}</span>
                <button onClick={onRemoveHandler} className={'deleteButton'}>x
                </button>
            </li>
        )
    })
}

если мы укажем console.log('want to change')
в функции onCheckboxChangeHandler то при нажатии по чекбоксам на странице увидим в консоли 
want to change

Выведем значение id той таски которая пытается измениться в консоль 

в консоли видим 

92cf3232-8e9f-11ed-95b0-db4296ac557b want to change
Todolist.tsx:63 92cf3233-8e9f-11ed-95b0-db4296ac557b want to change
Todolist.tsx:63 92cf3231-8e9f-11ed-95b0-db4296ac557b want to change

то есть так мы определяем какой чеекбокс хочет измениться

далее определяем на какое значение чекбокс хочет измениться
для этого используем в качестве параметра функции onCheckboxChangeHandler
event + его типизация

const onCheckboxChangeHandler = (e: ChangeEvent<HTMLInputElement>) => {
    console.log(task.id + ' want to change')
}

и теперь мы можем обратиться во время этого события к объекту е 
currentTarget - это тот элемент с которым произошло событие 
e - информация о событии, как props, как объект
и внутри этого объекта currentTarget 
e.currentTarget - это конкретное событие конкретного чекбокса в котором мы указали 
в атрибуте функцию onChange={onCheckboxChangeHandler}

и мы говорим что нам нужно значение e.currentTarget.checked - где будет содержаться информация
в каком положении находится checkbox true or false 

в консоли увидим 

92cf3233-8e9f-11ed-95b0-db4296ac557bfalse
Todolist.tsx:63 92cf3232-8e9f-11ed-95b0-db4296ac557btrue

итак, у нас есть task.id
console.log(task.id + e.currentTarget.checked)
мы нажимаем по чекбоксу  <input type="checkbox" onChange={onCheckboxChangeHandler} defaultChecked={task.isDone}/>
срабатывает функция onCheckboxChangeHandler()
и чек бокс нам сообщает task.id, task - берется из замыкания из параметра функции map 
e - приходит к нам параметром, а из е мы берем то значение на которое хочет поменяться функция 
и все что нужно сделать, внутри этого обработчика вызвать фукнцию
changeStatus
то есть changeStatus должна быть прокинута из App в Todolist через props

Теперь вместо console.log нужно вызвать функцию changeStatus 

const onCheckboxChangeHandler = (e: ChangeEvent<HTMLInputElement>) => {
    props.changeStatus(task.id, e.currentTarget.checked)
}

То есть при клике по чек боксу мы из Todolist вызываем функцию находящуюся в App 

function changeStatus(taskId: string, isDone: boolean) {
    let tasksCS = tasksUS.find((task) => task.id === taskId)
    if(tasksCS) {
    tasksCS.isDone = isDone
    }
    setTasksUS(tasksUS)
}

эта функция находит таску меняет ей значение на то которое мы передаем  e.currentTarget.checked
и устанавливает новый массив с измененой таской setTasksUS(tasksUS) в стейт
после чего ничего не происходит, потому что реакт не заметил что таска изменилась внутри массива

Потому что для реакта структура данных это массив, а массив может быть огромным, и реакт не пробегается 
второй раз чтобы уточнить не изменилось ли какое-либо свойство в массиве

Раз мы реакту передали тот же самый массив - значит внутри ничего не поменялось, 
свойства объектов входящих в массив не проверяются реактом 

Реакт так воспринимает что если что-то в массиве бы поменялось то 
ему бы вернули копию объекта а не сам объект с измененным свойством 1 таски

Поэтому мы делаем копию массива 

Если мы в 

function changeStatus(taskId: string, isDone: boolean) {
    let tasksCS = tasksUS.find((task) => task.id === taskId)
    if(tasksCS) {
    tasksCS.isDone = isDone
    }
    setTasksUS(tasksUS)
}

вместо setTasksUS(tasksUS) поставим пустой массив
setTasksUS([]) - то все li исчезнут, но мы увидим что реакт среагировал

Поэтому мы создаем новый массив и добавляем в него все теже элементы кроме 1 свойства 1 таски
но для реакта он будет новым массивом 

let copyTasksUS = [...tasksUS]
setTasksUS(copyTasksUS)

function changeStatus(taskId: string, isDone: boolean) {
    let tasksCS = tasksUS.find((task) => task.id === taskId)
    if(tasksCS) {
    tasksCS.isDone = isDone
    }
    let copyTasksUS = [...tasksUS]
    setTasksUS(copyTasksUS)
}

можно упростить 
вместо 
let copyTasksUS = [...tasksUS]
setTasksUS(copyTasksUS)
лучше
setTasksUS([...tasksUS])


__________ Отмена Добавления пустой таски

Для отмены добавления таски без текста или только с пробелами 

Помним про функцию которая непосредственно добавляет таску addTask 
она получает title в том виде в котором мы напечатали текст в инпуте (поле ввода)
создает новый объект task с этим новым свойством title 
и добавляет эту переменную в копию массива

let newTask = {id: v1(), title: newTaskTitle, isDone: false}
let newTasks = [newTask, ...tasksUS]

в который попадают все таски с новой вместе 
и этот новый массив устанавливает в стейт 

можно защиту от пустой таски сделать в ней и сказать что если title= пустой строке
то ничего не отрисуется 

еще можно защиту поставить в Todolist при вызове этой функции   

Лучше всего ставить защиту в том месте где находится контроль над вводом данных 

<button onClick={addTask}>+</button>

const addTask = () => {
    props.addTask(newTaskTitle)
    setNewTaskTitle('')
}

отсюда при нажатии мы отправляем новый title в business bll App 
поэтому здесь защиту и поставим 

const addTask = () => {
    if (newTaskTitle === '' ) {
    return; - обрывает действие функции дальше она не будет выполнятся если значение ''
    }
    props.addTask(newTaskTitle)
    setNewTaskTitle('')
}

но '  ' пробелы добавляются по прежнему поэтому 
используем метод trim() который с обоих сторон строки обрезает пробелы

const addTask = () => {
    if (newTaskTitle.trim() === '' ) {
    return;
    }
    props.addTask(newTaskTitle)
    setNewTaskTitle('')
}

Для того чтобы нельзя было ввести верное значение со случайным пробелом до наименования 
или после добавляем еще один метод trim   props.addTask(newTaskTitle.trim())

    const addTask = () => {
        if (newTaskTitle.trim() === '' ) {
            return;
        } - сторож страж
        props.addTask(newTaskTitle.trim())
        setNewTaskTitle('')
    }

результат - на страницу добавится без пробела 

После того как пользователь попытался добавить пустую таску, наша задача
проинформировать его о том что он поступает не правильно
надписью 'title is required'

добавляем стили в App.css

.error {
border: red 1px solid;
}

.error-message {
color: red;
}

далее добавляем className инпуту в который вводим текст

<input value={newTaskTitle}
    onChange={onNewTitleChangeHandler}
    onKeyPress={onKeyPressHandler}
    className='error'
/>

рамка инпута стала красной на то что мы не импортировали стили из App в Todolist

Теперь опишем текст об ошибке 
под кнопкой + создаем div

<div className='error-message'>Title is required</div>

все отображается, теперь решаем вопрос с тем когда этим красным фрагментам отображаться 
они должны отображаться только после попытки запостить пустую таску 

className={error ? 'error' : ''} - если error - существует то тогда мы добавим класс error а иначе ''
{ error && <div className='error-message'>{error}</div> - если ошибка существует то тогда показыва эту дивку
{error} - текст ошибки
error подчеркивает красным потому что ранее таких переменных не было
идея такая что error может меняться   

jsx может измениться только если поменялись props или поменялся state
если речь идет об автоматической перерисовке то речь идет про state 
Если меняется state это заставляет компоненту перерисовываться 
возвращая новый jsx 
то есть мы в той компоненте где собираемся менять jsx 
то есть есть ошибка либо нет ошибки - соотв отрисовка 

значит у самого todolista будет дополнительный стейт
который будет содержать ту самую ошибку изначально ошибка будет равна null 
то есть ее не будет но как только будет предпринята попытка 
добавить таску с пустым заголовком мы будем error устанавливаться в какое -то 
значение это заставит компоненту перерисоваться и отобразить этот jsx 

Для этого в этой же компоненте в todolist создаем новый стейт

const [error, setError] = useState('') - '' потому что '' - это псевдо ложь false
поэтому сработает как null но можно и null 

useState - по началу ('') ошибки нет
Если будет пустая строка то
className={error ? 'error' : ''} 
станет
className={ '' ? 'error' : ''} то есть className={ false ? 'error' : ''} - а если false 
значит отобразится ''
а если она не будет пустая а с символами то отобразится true и ошибка покажется хотя не должна когда есть символы

{error && <div className='error-message'>{error}</div>} - если здесь есть какой-то текст
то есть если error выдает true только тогда div отрисуется
если error - false второе выражение не будет выполняться 
то есть когда '' - выражение выполнятся не будет 

Добавляем условие в функцию addTask когда title - нет то есть null

const addTask = () => {
if (newTaskTitle.trim() !== '' ) {
props.addTask(newTaskTitle.trim())
setNewTaskTitle('')
} - это когда title - есть 

а 

const addTask = () => {
if (newTaskTitle.trim() !== '' ) { не равен? значит добавляем ->  
props.addTask(newTaskTitle.trim())
setNewTaskTitle('')
} else {
    setError('Title is required') - подчеркивает красным
} - когда у нас title равен пустой строке 
    
чтобы не подчеркивало добавляем типизацию в useState к error 

const [error, setError] = useState<string | null>(null)

теперь и null и 'Title is required' удовлетворяет этому типу 

Теперь при попытке отправить пустую строку в поле ввода 
поле ввода на странице подчеркивается красным и появляется надпись title is required
но во время набора красная надпись об ошибке все равно остается поэтому 
чтобы ее убрать
добавляем в onKeyPressHandler
setError(null) чтобы при нажатии каждой клавиши отправлять null в стейт

const onKeyPressHandler = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.charCode === 13) {
    setError(null)
    props.addTask(newTaskTitle)
    setNewTaskTitle('')
    }
}

теперь красная надпись исчезает и обводка вокруг поля ввода тоже 

________________ Теперь подсвечиваем текущую кнопку в фильтрации чтобы пользователь 
мог ориентироваться на какой вкладке он находится 

Добавляем для этого css класс в App.css

.active-filter {
background-color: aquamarine;
}

первым делом просто добавим данный класс кнопке и просто проверим срабатывает ли он
работает
а нам надо этот класс добавлять только если сейчас активно соотв значение для каждой кнопки

поэтому берем нужные таски из значения filter from useState from App.tsx
и передаем их через props в качестве атрибута в компоненту Todolist

<Todolist
title={'Benny Benassi'}
tasksForTodolist={tasksForTodolist}
removeTask={removeTask}
addTask={addTask}
changeFilter={changeFilter}
changeStatus={changeStatus}
filter={filter}
/>

добавляем типизацию export type FilterValuesType = 'all' | 'completed' | 'active'

type TodolistType = {
title: string
tasksForTodolist: Array<tasksForTodolistType>
removeTask: (id: string) => void
changeFilter: (value: FilterValuesType) => void
addTask: (inputTitle: string) => void
changeStatus: (taskId: string, isDone: boolean) => void
filter: FilterValuesType
}

Теперь у нас есть фильтр и мы можем добавить кнопке нужный класс в зависимости 
от какой сейчас у нас в props пришел в наш todolist фильтр all active or completed 

<button className={props.filter === 'all' ? 'active-filter' : ''}
onClick={onAllClickHandler}>All</button>
<button className={props.filter === 'active' ? 'active-filter' : ''}
onClick={onActiveClickHandler}>Active</button>
<button className={props.filter === 'completed' ? 'active-filter' : ''}
onClick={onCompletedClickHandler}>Completed</button>

теперь каждая выбираемая кнопка горит аквамарином


Далее сделаем чтобы выполненые таски стали блеклыми полупрозрачными 
добавляем класс в App.css

.is-done {
    opacity: 0.5;
}

Для начала просто добавим этот класс - li

<li key={task.id} className={'is-done'}>

теперь все пункты списка стали полупрозрачными
поэтому добавляем условие

<li key={task.id} className={task.isDone ? 'is-done' : ''}>

теперь если таска выбрана то она становится полупрозрачной 

it works!

Под транспиляцией понимается процесс преобразования кода, написанного с помощью следующих версий языка 
или на диалектах JavaScript в некий стандартный вариант, понимаемый всеми браузерами.
Для его осуществления предназначен Babel

Компиляция - это процесс преобразования компьютерной программы, 
написанной на данном языке, в эквивалентную программу на другом языке.
Компилятор - это программа для выполнения этой задачи.

Компилятор с русского на английский
Траспилятор с современного русского на древеславянский.

_________________________________________________ Todolist Plan _______________________

Monday

1 Вынести Todolist в отдельную компоненту, добавить uuid
2 Продублировать Todolist в App и передать разные заголовки
3 Создать массив с объектами (нашими данными) и передать их в Todolist
4 отмапить li
5 добавить в li кнопку и научить ее удалять таску
6 оживить кнопки фильтрации 
7 научить Todolist добавлять таску по клику, enter(у) и не добавлять пустые таски
8 оживить checkbox
9 научить Todolist отображать ошибки
10 сделать стили для фильтрующих кнопок

Tuesday

1 добавить и отмапить Todolistы
2 кнопки фильтрации должны работать каждая со своим списком соответственно
3 заставить Todolistы показывать разные таски (ассоциативный массив)
4 переписать все функции под работу с данными из ассоциативного массива
5 добавить кнопку и научить ее удалять Todolistы
6 задать типизацию для ассоциативного массива